--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by ukyohpq.
--- DateTime: 17/12/26 11:50
---

---@class ClassInfo
---@field className string
---@field luaPath string

---@type table<string, table> @ key:classname, value:class for this classname
local classMapForClassName = {}
---@type table<string, table> @ key:classname, value:instances for this classname
local instanceMapForClassName = {}

local isReloading = false
local private = {}
local originClass = class


function class(classname, super)
    local instances = instanceMapForClassName[classname]
    if instances == nil then
        instances = {}
        setmetatable(instances, {__mode = "k"})
        instanceMapForClassName[classname] = instances
    end

    local oldCls = classMapForClassName[classname]
    if oldCls ~= nil then
        if isReloading == false then
            LogUtil.LogError("duplicate class:%s", classname)
        else
            return oldCls
        end
    end
	---@class cls
	---@field super
    local cls = originClass(classname, super)
    if rawget(cls, private) == nil then
        rawset(cls, private, {})
    end
    cls.__index = function(t, k)
        --构造闭包用于注册回调的hotfix
        --注意cls[k]不能写成局部变量，必须查询，才能热更
        if type(cls[k]) == "function" then
            if cls[private][k] == nil then
                cls[private][k] = function(...) return cls[k](...) end
            end
            return cls[private][k]
        end
        return cls[k]
    end
    local newFunc = cls.New
    cls.New = function(...)
        local instance = newFunc(...)
        instances[instance] = true
        return instance
    end
    cls.new = cls.New
    classMapForClassName[classname] = cls
    return cls
end


local function getLuaPathFromDebugInfo(srcPath)
    --for windows
    srcPath = string.gsub(srcPath, "@.\\", "")
    --for mac
    srcPath = string.gsub(srcPath, "@./", "")
    --both
    srcPath = string.gsub(srcPath, "@", "")
    srcPath = string.gsub(srcPath, ".lua", "")
    srcPath = string.gsub(srcPath, "/", ".")
    srcPath = string.gsub(srcPath, "\\", ".")
    local specialStr = "Scripts."
    local scriptsPoint = string.find(srcPath, specialStr)
    if scriptsPoint ~= nil then
        srcPath = string.sub(srcPath, scriptsPoint + string.len(specialStr))
    end
    --LogUtil.LogError(srcPath)
    --srcPath = string.sub(srcPath, string.find(srcPath, "Scripts"))
    return srcPath
end

local pathMap = {}

--local oldRequire = require
--require = function(luaPath)
--    local n = 2
--    local srcPath
--    while(true) do
--        local debugInfo = debug.getinfo(n)
--        if debugInfo == nil then
--            return oldRequire(luaPath)
--        end
--        srcPath = debugInfo.source
--        if srcPath == nil then
--            return oldRequire(luaPath)
--        end
--
--        if string.find(srcPath, ".lua") == nil then
--            n = n + 1
--        else
--            break
--        end
--    end
--    srcPath = getLuaPathFromDebugInfo(srcPath)
--    if pathMap[luaPath] == nil then
--        pathMap[luaPath] = {}
--    end
--    pathMap[luaPath][srcPath] = 1
--    --end
--
--    return oldRequire(luaPath)
--end

--local localG = {}
--local globalKey2LuaMap = {}
--setmetatable(_G, {
--    __index = function(t, k)
--        local debugInfo = debug.getinfo(2)
--        local targetPath = globalKey2LuaMap[k]
--        if targetPath ~= nil then
--            if pathMap[targetPath] == nil then
--                pathMap[targetPath] = {}
--            end
--            pathMap[targetPath][getLuaPathFromDebugInfo(debugInfo.source)] = 1
--        end
--        return localG[k]
--    end,
--    __newindex = function(t, k, v)
--        localG[k] = v
--        --if v.__cname ~= nil then
--        local debugInfo = debug.getinfo(2)
--        globalKey2LuaMap[k] = getLuaPathFromDebugInfo(debugInfo.source)
--        --end
--    end
--})

local blackList = {}

local function notFixPolicy(luaPath)
    if string.find(luaPath, "_Controller") ~= nil then return false end
    if string.find(luaPath, "_View") ~= nil then return false end
    return blackList[luaPath] == nil
end

function luaReload(luaPath, reloaded)
    LogUtil.Debug("luaReload")
    if notFixPolicy(luaPath) == false then
        LogUtil.LogError(1)
        return
    end
    if reloaded == nil then
        LogUtil.LogError(2)
        reloaded = {}
    end
    if reloaded[luaPath] ~= nil then
        LogUtil.LogError(3)
        return
    end
    reloaded[luaPath] = 1
    if  luaPath == "System.HotUpdate" or
        luaPath == "playerData.PlayerData" then
        LogUtil.LogError("log4")
        return
    end
    if package.loaded[luaPath] == nil then
        return
    end
    LogUtil.Debug("lua hot fix:%s", luaPath)
    local oldModel = package.loaded[luaPath]
    package.loaded[luaPath] = nil
    isReloading = true
    --require(luaPath)
    local err, ret = pcall(require, luaPath)
    if err == false then
        LogUtil.LogError(ret)
        package.loaded[luaPath] = oldModel
        return
    end
    isReloading = false
    local map = pathMap[luaPath]
    if map == nil then
        return
    end
    for k, v in pairs(map) do
        luaReload(k, reloaded)
    end
end